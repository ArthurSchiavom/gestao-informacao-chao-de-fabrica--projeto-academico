Nota: apesar de por links para sites, a maior parte desta matéria faz parte da aula teórica 6 ou 7

Em regra geral, getters e setters não devem existir. Se existirem, têm outro nome. Se existir um getter e um setter, considerar tornar a variável pública.

Uma classe não deve retornar um objeto para se fazer uma cadeia de operações, mas sim receber a informação de que necessita e retornar logo o resultado. Por exemplo, deve ser Utilizador.encontrarDepartamentos em vez de Utilizador.getFuncoes + filtrar. Exemplo 2: Mobiliario.contarParafusos() em vez de Mobiliario.getPecas() + peca.contarParafusos() + somar tudo (esta segundo lógica deve ficar dentro da classe Mobiliario, no método getPecas(). Ou seja, a classe fornece logo a informação alvo pronta a usar.

State: Uma classe comporta-se de maneira diferente consoante o seu estado. Por exemplo, temos um documento que pode estar em fase de Rascunho, EsperaAprovacao ou Publicado. Em vez de ter ifs que verificam qual o estado e fazem alguma coisa dentro do scope, criamos uma interface que tem o método publicar. Quando publicar é chamado num Rascunho, o documento passa ao estado de EsperaAprovacao, deixa de poder ser editado pelo utilizador e passa a estar visível para administradores. Esse comportamento será definido na classe EsperaAprovacao que tem um construtor EsperaAprovacao(documento). E a partir da classe mãe, podemos apenas executar estado.publicar(), sendo que esse estado está sempre atualizado.

Command: Interface para ações, como o execute() da classe Action da framework de eapli. Podemos assim, de certa maneira passar funções/ações por parâmetro (passamos uma classe que implementa a interface da ação). Exemplo: Interface Ação define execute(). Classe EnviarNotificaçãoErro implementa Ação. Agora podemos enviar uma instância de EnviarNotificaçãoErro, permitindo executar a sua implementação de ação, tal como poderiamos enviar outra implementação como EnviarNotificaçãoSucesso. Ou seja, temos liberdade de passar ações por parâmetros. Command pattern = callback

Composite: Classe que implementa uma interface A e tem uma lista de objectos que implementam a mesma interface A. Exemplo: Queremos calcular preço de 1 encomenda e temos lá dentro produtos e caixas com produtos (ou mais caixas). Implementamos a interface comPreco na Caixa e no Produto, assim, cada caixa devolve o price() do seu conteúdo. Se o conteúdo for uma caixa, então também essa caixa vai calcular o preço do seu conteúdo e devolver esse valor para a soma total. >>> https://refactoring.guru/design-patterns/composite

Visitor: Permite várias implementações de ações sobre objetos com uma interface comum, sendo cada ação específica para cada tipo de objeto. Exemplo: Um Carro tem um Motor, um Volante e um Corpo e todas estas partes implementam ElementoDeCarro. Temos então a interface VisitorElementoDeCarro que define visit(Motor motor), visit(Volante volante) e visit(Corpo corpo). Agora criamos implementações para esta interface: ImprimirElementoCarroVisitor e FabricarElementoCarroVisitor. No entanto, para poder utilizar o método visit para o tipo específico (Motor, Volante e Corpo), a interface ElementoDeCarro implementa o método accept(Visitor v), que é definido como { v.visit(this); }. Ou seja, podemos agora fazer motor.accept(ImprimirElementoCarroVisitor) e o motor vai correr o método ImprimirElementoCarroVisitor.visit(Motor motor). O que nos deixa a possibilidade de usar visitors para objetos ou conjuntos de objetos genericamente. Se quisermos então imprimir todas as peças do carro, fazemos uma loop por todos os ElementoDeCarro e utilizamos elemento.accept(imprimirElementoCarroVisitor).

Service - Objeto intermediário para quando uma relação não se encaixa no domínio. Por exemplo, numa tranferência de dinheiro entre contas bancárias, não faz sentido ser uma conta a mandar dinheiro para outra, porquê não é a conta que faz a transferência, quem faz é o serviço de transferência/banco. Então podemos ter um objeto intermediário chamado servicoDeTranferência que fica encarregue das tranferências.

Controller - Intermediário entre funcionalidades e UI -> retorna apenas o resultado para a UI apresentar.

Polimorfismo - Herança. Usado para criar um caso particular de algo, não necessáriamente para reutilizar código. >>> T7

!!!Dependency inversion principle - O código depende de abstrações, não de classes concretas. Diminui o acoplamento. >>> T7

!!!Open/Closed principle - Classes são abertas para extensão mas fechada para modificação (alteração de comportamento). >>> T7

!!!Protected variation - Identificar sistemas que têm maior probabilidade de variação e construir interfaces à volta dos mesmos, para não ter que modificar o resto do código ao adicionar novas implementações (assim não precisamos modificar a classe, porque podemos criar uma nova e manter as duas implementações diferentes. Podemos assim aplicar o open/closed principle). >>> T7

Liskov Substitution principle - Subclasses devem seguir o contrato e todos os invariantes da classe base, ou seja, a subclasse deve sempre ser capaz de atuar, em todos os aspetos, como a classe base. >>> T7

Dependency inversion - Superclasses/interfaces não podem depender das subclasses/implementações. As entidades devem depender de abstrações.

Pure fabrication - Criação de uma classe que não faz parte do modelo de domínio apenas para atingir menor acoplamento e maior coesão. Estas classes são chamadas de serviços. (UI e Controller)

IE - Uma classe tem uma função clara, específica e bem delimitada, que reflete a informação que guarda.

HC/LC - Cada pedaço de código deve ser o mais independente possível e ter responsabilidades claramente definidas. Acoplamento (interdependência) dentro de packages é normal, devemos minimizar é o acoplamento entre packages.

Adapter: Para quando a interface fornecida é diferente da esperada. Podemos traduzir a fornecida para ser compatível com a esperada. Por exemplo, um adapter que converta CSV em JSON, porque o programa espera um JSON, não um CSV. >>> T8 - More GoF Patterns

Observer - Publicação e subscrição de eventos. O publicador tem uma lista de subscritores e notifica-os quando o evento ocorre. Os subscritores implementam uma interface, que é o que o publicador usa para os notificar. >>> https://refactoring.guru/design-patterns/observer

Singleton - Single instance class. Private constructor and static method that instantiates the class and returns it. Following invocations to the static method return the already created object. >>> https://refactoring.guru/design-patterns/singleton

Facade - Classe que fornece uma interface simples para uma framework complexa (por interface não quero dizer necessáriamente UI). >>> https://refactoring.guru/design-patterns/facade

Template - Classe template que tem certas coisas especificas não implementadas que podem ser definidas em subclasses. >>> https://refactoring.guru/design-patterns/template-method

Decorator - Adiciona comportamentos extra às funcionalidades de uma interface A ao fazer wrapping da classe e criar métodos que usam os métodos da interface A, mas que fazem também algo mais (comportamento extra). O decorator **implementa** a interface que está a decorar e tem uma instância de outra classe que implementa a intarface (representada por uma instância da interface), assim garante-se a implementação de todos os métodos. >>> https://refactoring.guru/design-patterns/decorator

Strategy - Simplesmente uso de interfaces -> Classe que apenas define comportamentos sem os implementar, sendo que podem ser implementados de diferentes por outras classes. As classes que implementam podem ser utilizadas como uma instância da superclasse SEMPRE (deve obedecer aos propósitos da interface). Factories podem ser usadas para selecionar a implementação correta. >>> https://refactoring.guru/design-patterns/strategy

Builder - Para quando têm que construir algo que tem partes opcionais. Por exemplo, querem um objeto do tipo Casa mas uma casa pode como pode não ter uma garagem, um jardim, uma piscina, múltiplos pisos, etc. Uma boa maneira de construir o objeto casa poderá ser com um builder. Nesse caso, usamos a classe CasaBuilder e os seus métodos consoante necessário: .addPiso(), .addGaragem(), .setColor(), .setHeight(),... e no final usamos casaBuilder.build() que nos retorna o objeto Casa tal como queremos. Quaisquer interligações e cálculos dependentes das configurações podem ser realizados quando o Build() é feito. !!! Neste caso o builder pode também selecionar o construtor correto se aplicável. >>> https://refactoring.guru/design-patterns/builder

Creator - Em geral, uma classe B deve ser responsável por criar instâncias de classe A se uma, ou preferencialmente mais, das seguintes afirmações se aplicam:
        * Instâncias de B contêm ou agregam instâncias de A;
        * Instâncias de B gravam instâncias de A;
        * Instâncias de B utilizam de perto instâncias de A;
        * Instâncias de B têm as informações de iniciação das instâncias de A e passam isso na criação.
        Ou seja, B gere A.
    >>> Teórica

Simple factory - Classe com apenas métodos de fábrica. As classes que tenham uma fábrica devem então ter o seu construtor privado, protected ou package private. As fábricas fornecem métodos que facilitam a instanciação de classe(s) através do seu supertipo. Por exemplo, imaginemos que temos uma empresa de transportes que utiliza Navios e Camiões. Neste caso, podemos usar uma factory que instancie um Veiculo do tipo Navio ou Camião dependendo do contexto e retorne esse Veiculo. Exemplo de um contexto: O utilizador a utilizar o sistema é o gestor de transportes maritmos, logo o veiculo será do tipo Navio. Quando usar? Quando temos diferentes tipos e contextos. Quando temos bastante lógica de construção, como no caso de pools (lista de objetos reutilizáveis quando disponíveis): Quando objetos podem ser reutilizados, então a factory retorna o objeto correto. >>> https://refactoring.guru/design-patterns/factory-method

Abstract factory - Interface [genérica] para factories. Útil quando queremos consistência entre conjuntos de diferentes tipos usados por simple factories. Por exemplo, temos mobiliário do tipo moderno e vitange. Cada um destes grupos tem o seu tipo de cadeira, de mesa, de roupeiro,... E queremos tê-los **agrupados** para, por exemplo, simular um design consistente de uma casa. Então usamos uma abstract factory. A interface MobiliarioFactory define os métodos criarCadeira(), criarMesa() e criarRoupeiro(). A classe MobiliarioVintageFactory implementa esta interface e os seus métodos para instanciarem classes de mobiliário do tipo vintage, tal como a MobiliarioModernoFactory implementa para mobiliário do tipo moderno. >>> https://refactoring.guru/design-patterns/abstract-factory

Factories:
    * Fazem parte da camada de dominío.
    * Permitem garantir a consistência do domínio e esconder as especificações da criação de objetos.
    * Podemos ter uma fábrica a decidir se estamos em cenário de mock ou real.
    * Há vários tipos de fábricas (como para UI e persistência), mas só vamos usar o de entidades do domínio.
    * Nem todos as classes necessitam de fábrica. "Senso comum". A maior parte dos objetos são simples de criar e não necessitam de fábrica.
    >>> Teórica
    
Repository pattern - Temos uma interface que abstrai a persistência de objetos, com métodos como findById(), save(), delete(),...

Nota importante: Devemos usar e abusar de queries. Para uma situação como pesquisa de um objeto na base de dados, devemos fazê-lo através de uma query e não, por exemplo, ao buscar todos os objetos e filtrar no código. Ou seja, usar queries quando aplicável.
    >>> Teórica

Repositories:
    * Fazem parte da cama de persistência.
    * Devem implementar uma interface, que permite a mudança de tecnologia sem impacto no funcionamento da aplicação.
    * Devem ter os métodos de pesquisa lá dentro, como findByMonth e getAverageRetailPrice. O repositório é capaz de efetuar estas pesquisas de maneira eficiente. No entanto, não devemos ter lógica de negócio na camada de persistência. Por exemplo, se tivermos o cálculo de idade, é discutível se deve estar na camada de persistência ou na de domínio. 
    >>> Teórica
    
Vertical slicing - Dividimos os packages por funcionalidade (registar utilizador, bloquear utilizador,...) e dentro desses por tecnologia (UI, data access layer, business logic later,...)
